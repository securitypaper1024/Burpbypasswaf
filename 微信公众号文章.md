# 字符编码绕过WAF | Burp插件开发实战

#### 0x00 背景

渗透测试中，WAF经常拦截我们的Payload。本文介绍一种**字符编码绕过技术**，并开源Burp插件实现一键Fuzz。

**项目地址**：https://github.com/securitypaper1024/Burpbypasswaf

---

#### 0x01 原理

核心思路：**WAF无法解析的编码，后端服务器却能解析**。

```
正常请求 (UTF-8)              编码后请求 (IBM037)
┌─────────────────┐         ┌─────────────────┐
│ <script>alert   │    →    │ [EBCDIC字节流]   │
└────────┬────────┘         └────────┬────────┘
         ↓                           ↓
    WAF ✗ 拦截                   WAF ✓ 放行
                                     ↓
                                后端解码执行
```

---

#### 0x02 支持的编码

| 类型 | 编码 | 说明 |
|------|------|------|
| **EBCDIC** | IBM037, IBM500, IBM1026 | 最有效，多数WAF不支持 |
| **Unicode** | UTF-16, UTF-16BE/LE, UTF-32 | 多字节使正则失效 |
| **其他** | ISO-8859-1, Windows-1252 | 特殊字符处理 |

---

#### 0x03 插件功能

- 12种编码一键Fuzz
- 自动更新Content-Type/Length
- 批量发送，响应对比
- 右键菜单集成

---

#### 0x04 安装

1. 下载 Jython：https://www.jython.org/download
2. Burp → Extender → Options → 设置Jython路径
3. Extender → Add → Python → 选择 `waf_bypass_burp.py`

---

#### 0x05 使用

1. Repeater右键 → `WAF Bypass Encoder` → `Send to Panel`
2. 点击 `Fuzz All` 生成编码变体
3. 点击 `Send All Fuzz` 批量发送
4. 对比响应判断绕过效果

---

#### 0x06 实战案例

**目标**：某OA系统SOAP接口

| 编码 | 响应 | 结果 |
|------|------|------|
| UTF-8 | 无响应 | WAF拦截 |
| IBM037 | 500 | **绕过成功** |
| UTF-16 | 400 | 服务器不支持 |

响应从"无响应"变为"500"，说明请求到达后端，WAF绕过有效。

---

#### 0x07 响应判断

| 状态码 | 含义 |
|--------|------|
| 200 | 绕过成功，可利用 |
| 500 | 绕过成功，到达后端 |
| 400 | 服务器不支持该编码 |
| 403/无响应 | WAF拦截 |

---

#### 0x08 防御建议

1. WAF支持多种编码解析
2. 未知编码默认拒绝
3. 后端限制支持的编码

---

**项目地址**：https://github.com/securitypaper1024/Burpbypasswaf

*免责声明：仅供授权安全测试使用*
